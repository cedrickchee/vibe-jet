<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fly MMO</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
        }
    </style>
    <link rel="shortcut icon" href="#">
</head>
<body>
    <div id="loading-indicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; font-family: monospace; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 5px; display: none;">
        Loading Model...
    </div>
    <div id="info">
        Speed: <span id="speed">0</span> km/h<br>
        Altitude: <span id="altitude">0</span> m<br>
        Players: <span id="players-count">1</span>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Optional for debugging

        // --- Configuration ---
        const WEBSOCKET_URL = 'ws://localhost:8080'; // Adjust if your server is elsewhere
        const PLAYER_SPEED = 50.0; // Base speed units/sec
        const AFTERBURNER_MULTIPLIER = 3.0;
        const ROLL_SPEED = Math.PI * 1.0; // Radians per second
        const PITCH_SPEED = Math.PI * 0.8; // Radians per second
        const YAW_SPEED = Math.PI * 0.5; // Radians per second
        const DAMPING = 0.95; // Velocity damping factor
        const CAMERA_BASE_FOV = 75;
        const CAMERA_MAX_FOV_BOOST = 25; // Additional FOV at max speed boost
        const UPDATE_INTERVAL_MS = 100; // Send updates every 100ms (10 Hz)
        const GROUND_SIZE = 5000;
        const BUILDING_COUNT = 300;
        const MAX_BUILDING_HEIGHT = 400;
        const MIN_BUILDING_HEIGHT = 50;
        const STAR_COUNT = 5000;
        const DAY_NIGHT_CYCLE_MINUTES = 5; // Duration of a full day/night cycle
        // const MODEL_URL = 'https://unpkg.com/three@0.162.0/examples/models/gltf/Flamingo.glb'; // <-- REPLACE WITH YOUR AIRCRAFT MODEL URL (.glb/.gltf)
        const MODEL_URL = 'shenyang_j-11.glb'; // <-- Use local filename
        const MODEL_SCALE = 0.8; // <-- ADJUST THIS scale to fit your model size
        const OTHER_PLAYER_COLOR = 0x00aaff; // A blue tint for other players

        // --- Global Variables ---
        let scene, camera, renderer, clock, skyLight, sunLight;
        let playerAircraft = null; // Initialize as null
        let playerVelocity, playerAngularVelocity;
        let controls = { forward: 0, backward: 0, left: 0, right: 0, up: 0, down: 0, boost: 0 };
        let ws;
        let playerId = null;
        let otherPlayers = new Map(); // Map<playerId, { mesh: THREE.Mesh, lastUpdate: number }>
        let buildingBoundingBoxes = [];
        let lastUpdateTime = 0;
        let isColliding = false;
        let sunAngle = Math.PI / 4; // Start in morning/afternoon
        let loadedModelTemplate = null; // To store the loaded model for cloning
        let loadingManager = null;      // Optional for loading progress
        let loadingIndicator = null;    // Simple DOM element for loading message

        // --- Initialization ---
        function init() {
            // Basic Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CAMERA_BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 20000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            // --- Get Loading Indicator ---
            loadingIndicator = document.getElementById('loading-indicator');

            // Lighting (Day/Night)
            skyLight = new THREE.HemisphereLight(0x87ceeb, 0x000000, 0.6); // Sky, Ground, Intensity
            scene.add(skyLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(0, 1000, 1000); // Initial position
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048; // Higher resolution shadows
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 100;
            sunLight.shadow.camera.far = 5000;
            sunLight.shadow.camera.left = -GROUND_SIZE / 2;
            sunLight.shadow.camera.right = GROUND_SIZE / 2;
            sunLight.shadow.camera.top = GROUND_SIZE / 2;
            sunLight.shadow.camera.bottom = -GROUND_SIZE / 2;
            scene.add(sunLight);
            scene.add(sunLight.target); // Important for directional light targeting

            // Fog
            scene.fog = new THREE.Fog(0xcccccc, 1000, 15000);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Buildings
            createBuildings();

            // Stars
            createStars();

            // --- Load Assets & Initialize ---
            loadResources(); // <--- Start loading resources

            // Player Aircraft
            createPlayerAircraft();

            // Controls Setup
            setupControls();

            // WebSocket Setup
            setupWebSocket();

            // Handle Window Resize
            window.addEventListener('resize', onWindowResize, false);

            // Start Animation Loop (will be started later in initializeGame)
            // animate();
        }

        function showLoadingIndicator(show) {
            if (loadingIndicator) {
                loadingIndicator.style.display = show ? 'block' : 'none';
            }
        }

        function loadResources() {
            showLoadingIndicator(true);
            loadingManager = new THREE.LoadingManager();
            const loader = new GLTFLoader(loadingManager);

            loader.load(
                MODEL_URL,
                // --- Success Callback ---
                (gltf) => {
                    console.log("Model loaded successfully.");
                    loadedModelTemplate = gltf.scene; // Store the loaded scene

                    // --- Apply settings to the template once ---
                    loadedModelTemplate.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);

                    // Ensure model casts shadows (traverse the loaded scene)
                    loadedModelTemplate.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            // Optional: Also allow receiving shadows if needed
                            // child.receiveShadow = true;
                        }
                    });

                    // --- IMPORTANT: Rotate template if needed ---
                    // Models might not be oriented along +Z by default.
                    // Add rotations here to align the template correctly. Example:
                    // loadedModelTemplate.rotateY(Math.PI); // Rotate 180 degrees if it faces -Z

                    initializeGame(); // Proceed with game setup
                },
                // --- Progress Callback (Optional) ---
                (xhr) => {
                    // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    // You could update the loading indicator text here
                },
                // --- Error Callback ---
                (error) => {
                    console.error('An error happened during model loading:', error);
                    showLoadingIndicator(false);
                    displayError("Failed to load aircraft model. Please check console and refresh.");
                }
            );
        }

        function initializeGame() {
            showLoadingIndicator(false); // Hide loading indicator
            console.log("Initializing game...");

            if (!loadedModelTemplate) {
                console.error("Model template not loaded before initializing game!");
                displayError("Initialization Error. Model not ready.");
                return;
            }

            // --- Create Player Aircraft (now clones the loaded model) ---
            createPlayerAircraft();

            // --- Setup Controls ---
            setupControls();

            // --- WebSocket Setup ---
            setupWebSocket();

            // --- Start Animation Loop ---
            animate(); // <-- START the loop HERE
            console.log("Game initialized and animation loop started.");
        }

        function createBuildings() {
            const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8, metalness: 0.2 });
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1); // Base geometry

            for (let i = 0; i < BUILDING_COUNT; i++) {
                const height = Math.random() * (MAX_BUILDING_HEIGHT - MIN_BUILDING_HEIGHT) + MIN_BUILDING_HEIGHT;
                const width = Math.random() * 40 + 20;
                const depth = Math.random() * 40 + 20;

                const building = new THREE.Mesh(buildingGeometry, buildingMaterial.clone()); // Clone material if needed
                building.scale.set(width, height, depth);

                const x = (Math.random() - 0.5) * (GROUND_SIZE * 0.9); // Keep away from edge slightly
                const z = (Math.random() - 0.5) * (GROUND_SIZE * 0.9);
                building.position.set(x, height / 2, z);

                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Store bounding box for collision
                const box = new THREE.Box3().setFromObject(building);
                buildingBoundingBoxes.push(box);
            }
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true });
            const starVertices = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                const x = (Math.random() - 0.5) * 15000;
                const y = Math.random() * 5000 + 500; // Keep stars above a certain height
                const z = (Math.random() - 0.5) * 15000;
                // Ensure stars are far enough away
                if(Math.sqrt(x*x + y*y + z*z) > 1000) {
                     starVertices.push(x, y, z);
                } else {
                    i--; // retry if too close
                }
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }


        function createPlayerAircraft() {
            // Simple cone shape for the aircraft body
            // const geometry = new THREE.ConeGeometry(2, 8, 8); // Radius, Height, Segments
            // geometry.rotateX(Math.PI / 2); // Point forward along Z
            // const material = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x330000 });
            // playerAircraft = new THREE.Mesh(geometry, material);
            // playerAircraft.position.set(0, 50, 0); // Start above ground
            // playerAircraft.castShadow = true;
            
            if (!loadedModelTemplate) {
                console.warn("Cannot create player aircraft, model template not loaded.");
                return;
            }
            console.log("Creating player aircraft from template...");

            // --- Clone the loaded model ---
            playerAircraft = loadedModelTemplate.clone(); // Use THREE.SkeletonUtils.clone(loadedModelTemplate) if model is animated/skinned

            // --- Set Initial Position ---
            // Note: Scale and shadow settings are inherited from the template
            playerAircraft.position.set(0, 50, 0);
            
            // --- Add to Scene ---
            scene.add(playerAircraft);
            console.log("Player aircraft added to scene at", playerAircraft.position);

            // Initialize physics variables
            // Ensure these are created AFTER playerAircraft is assigned
            playerVelocity = new THREE.Vector3();
            playerAngularVelocity = new THREE.Vector3();

            // Attach camera to the player (adjust offset as needed)
            // camera.position.set(0, 3, -10); // Behind and slightly above
            // camera.position.set(0, 5, -20); // Further back (Z=-20) and slightly higher (Y=5)
            // playerAircraft.add(camera);
        }

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'KeyW': case 'ArrowUp':    controls.forward = 1; break;
                    case 'KeyS': case 'ArrowDown':  controls.backward = 1; break; // Optional: Brake/Reverse?
                    case 'KeyA': case 'ArrowLeft':  controls.left = 1; break; // Yaw left
                    case 'KeyD': case 'ArrowRight': controls.right = 1; break; // Yaw right
                    case 'KeyQ':                    controls.rollLeft = 1; break; // Roll left
                    case 'KeyE':                    controls.rollRight = 1; break; // Roll right
                    case 'ShiftLeft': case 'ShiftRight': controls.boost = 1; break;
                    case 'ControlLeft': case 'ControlRight': controls.down = 1; break; // Pitch down
                    case 'Space':                   controls.up = 1; break;     // Pitch up
                }
            });

            document.addEventListener('keyup', (event) => {
                 switch(event.code) {
                    case 'KeyW': case 'ArrowUp':    controls.forward = 0; break;
                    case 'KeyS': case 'ArrowDown':  controls.backward = 0; break;
                    case 'KeyA': case 'ArrowLeft':  controls.left = 0; break;
                    case 'KeyD': case 'ArrowRight': controls.right = 0; break;
                    case 'KeyQ':                    controls.rollLeft = 0; break;
                    case 'KeyE':                    controls.rollRight = 0; break;
                    case 'ShiftLeft': case 'ShiftRight': controls.boost = 0; break;
                    case 'ControlLeft': case 'ControlRight': controls.down = 0; break;
                    case 'Space':                   controls.up = 0; break;
                }
            });
        }

        function setupWebSocket() {
            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                console.log('WebSocket connection established');
                // Maybe request initial game state or player ID here if needed
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // console.log('Message from server:', message);

                    switch(message.type) {
                        case 'assign_id':
                            playerId = message.id;
                            console.log('Assigned player ID:', playerId);
                            break;
                        case 'player_update':
                            if (message.id !== playerId) { // Update other players
                                updateOtherPlayer(message.id, message.data);
                            }
                            break;
                        case 'player_join':
                            if (message.id !== playerId) {
                                console.log('Player joined:', message.id);
                                addOtherPlayer(message.id, message.data);
                            }
                            break;
                        case 'player_leave':
                            if (otherPlayers.has(message.id)) {
                                console.log('Player left:', message.id);
                                removeOtherPlayer(message.id);
                            }
                            break;
                         case 'world_state': // Initial state for newly joined player
                            message.players.forEach(playerData => {
                                if (playerData.id !== playerId) {
                                    addOtherPlayer(playerData.id, playerData.data);
                                }
                            });
                            break;
                        default:
                            console.log('Unknown message type:', message.type);
                    }
                } catch (error) {
                    console.error('Failed to parse message or process:', error);
                }
                updatePlayerCount();
            };

            ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
                displayError("Connection error. Please refresh.");
            };

            ws.onclose = () => {
                console.log('WebSocket connection closed');
                playerId = null;
                // Clear other players? Or show they disconnected?
                otherPlayers.forEach(player => scene.remove(player.mesh));
                otherPlayers.clear();
                updatePlayerCount();
                displayError("Disconnected. Please refresh.");
            };
        }

        function displayError(message) {
             const errorDiv = document.createElement('div');
             errorDiv.style.position = 'absolute';
             errorDiv.style.top = '50%';
             errorDiv.style.left = '50%';
             errorDiv.style.transform = 'translate(-50%, -50%)';
             errorDiv.style.color = 'red';
             errorDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
             errorDiv.style.padding = '20px';
             errorDiv.style.fontSize = '20px';
             errorDiv.style.fontFamily = 'monospace';
             errorDiv.textContent = message;
             document.body.appendChild(errorDiv);
        }

        function addOtherPlayer(id, data) {
            // Don't add if player already exists or the model template isn't loaded yet
            if (otherPlayers.has(id) || !loadedModelTemplate) {
                // console.log(`Skipping addOtherPlayer for ${id}: Already exists or template not ready.`);
                return;
            }

            console.log(`Adding other player ${id} from template...`);
            const otherAircraftMesh = loadedModelTemplate.clone(); // Use THREE.SkeletonUtils.clone if needed

            // Use the same geometry/material for now, maybe different color later
            // const geometry = new THREE.ConeGeometry(2, 8, 8);
            // geometry.rotateX(Math.PI / 2);
            // const material = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue for others
            // const otherAircraft = new THREE.Mesh(geometry, material);
            // otherAircraft.castShadow = true; // Other players cast shadows too

            // Optional: Apply a visual tint or variation later if desired
            // 
            // Apply a visual difference (e.g., slight color tint) - This is complex
            // and depends heavily on the model's material structure.
            // Simple attempt: If materials are standard, try tinting.
            otherAircraftMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) { // Handle multi-materials
                        child.material.forEach(mat => {
                            if (mat.isMeshStandardMaterial) {
                                // Create a unique material instance to avoid changing the template/other clones
                                // Note: Cloning materials can be resource intensive
                                // child.material = mat.clone();
                                // child.material.color.multiplyScalar(0.7); // Example: Make it darker
                                // A simpler tint might just modify emissive or add a colored light later
                            }
                        });
                    } else if (child.material.isMeshStandardMaterial) {
                        // child.material = child.material.clone();
                        // child.material.color.multiplyScalar(0.7);
                    }
                }
            });
            // For now, let's skip complex material cloning/tinting and they'll look the same.
        
            // Set initial position and rotation from network data if provided
            if (data && data.position && data.quaternion) {
                try {
                    otherAircraftMesh.position.fromArray(data.position);
                    otherAircraftMesh.quaternion.fromArray(data.quaternion);
                } catch (e) {
                    console.error(`Error setting position/quaternion for player ${id}:`, e, data);
                }
            } else {
                // Place at default spawn or origin if no data provided? Or hide until first update?
                // For now, it will appear at (0,0,0) by default if no data.
            }

            // Add the mesh to the scene
            scene.add(otherAircraftMesh);
            otherPlayers.set(id, { mesh: otherAircraftMesh, lastUpdate: Date.now() });
            
            console.log(`Added player ${id} to scene.`);
            updatePlayerCount(); // Update the player count display
        }

        function updateOtherPlayer(id, data) {
            const player = otherPlayers.get(id);
            if (player) {
                // Simple interpolation could be added here for smoother movement
                player.mesh.position.fromArray(data.position);
                player.mesh.quaternion.fromArray(data.quaternion);
                player.lastUpdate = Date.now();
            } else {
                // If we receive an update for a player we don't know, add them
                addOtherPlayer(id, data);
            }
        }

        function removeOtherPlayer(id) {
            const player = otherPlayers.get(id);
            if (player) {
                scene.remove(player.mesh);
                otherPlayers.delete(id);
                console.log(`Removed player ${id} from scene.`);
                updatePlayerCount();
            }
        }

        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            updatePlayerMovement(deltaTime);
            updateCameraFOV();
            updateDayNightCycle(deltaTime);
            checkCollisions();

            // Send player state periodically
            const now = Date.now();
            if (ws && ws.readyState === WebSocket.OPEN && playerId && now - lastUpdateTime > UPDATE_INTERVAL_MS) {
                sendPlayerUpdate();
                lastUpdateTime = now;
            }

            // --- Manual Camera Following Logic ---
            if (playerAircraft) {
                // Define camera offset relative to the aircraft (behind, above)
                const relativeCameraOffset = new THREE.Vector3(0, 6, -18); // Adjust Y (height) and Z (distance) as needed

                // Calculate the desired world position of the camera
                const cameraOffset = relativeCameraOffset.applyQuaternion(playerAircraft.quaternion);
                const desiredCameraPosition = playerAircraft.position.clone().add(cameraOffset);

                // Smoothly move the camera to the desired position (lerp)
                // Use 0.1 for smoothing, or 1.0 to snap instantly for testing
                camera.position.lerp(desiredCameraPosition, 0.1);

                // Make the camera look at a point slightly above the aircraft's center
                const lookAtTarget = playerAircraft.position.clone().add(new THREE.Vector3(0, 1, 0)); // Look slightly above the origin
                camera.lookAt(lookAtTarget);
            }
            
            renderer.render(scene, camera);
            updateInfoPanel();
        }

        function updatePlayerMovement(deltaTime) {
            if (!playerAircraft) return;

            const currentSpeed = playerVelocity.length();
            const maxSpeed = PLAYER_SPEED * (controls.boost ? AFTERBURNER_MULTIPLIER : 1.0);

            // --- Calculate Forces/Torques ---
            let thrust = controls.forward ? PLAYER_SPEED * 5.0 : 0; // Acceleration force
            thrust = thrust * (controls.boost ? AFTERBURNER_MULTIPLIER : 1.0);
            // Optional: Add braking force if controls.backward is used
            // if (controls.backward) thrust = -PLAYER_SPEED * 2.0;

            let targetPitch = 0;
            if (controls.up) targetPitch = PITCH_SPEED;
            if (controls.down) targetPitch = -PITCH_SPEED;

            let targetYaw = 0;
            if (controls.left) targetYaw = YAW_SPEED;
            if (controls.right) targetYaw = -YAW_SPEED;

            let targetRoll = 0;
            if (controls.rollLeft) targetRoll = ROLL_SPEED;
            if (controls.rollRight) targetRoll = -ROLL_SPEED;

            // --- Apply Angular Velocity ---
            // Simple angular acceleration based on input
            playerAngularVelocity.x += (targetPitch - playerAngularVelocity.x) * deltaTime * 5.0; // Pitch
            playerAngularVelocity.y += (targetYaw - playerAngularVelocity.y) * deltaTime * 5.0;   // Yaw
            playerAngularVelocity.z += (targetRoll - playerAngularVelocity.z) * deltaTime * 5.0; // Roll

            // Apply damping to angular velocity
            playerAngularVelocity.multiplyScalar(DAMPING);

            // --- Apply Rotation ---
            const deltaRotation = playerAngularVelocity.clone().multiplyScalar(deltaTime);
            const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaRotation.x);
            const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaRotation.y);
            const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), deltaRotation.z);

            // Apply rotations in aircraft's local frame
            playerAircraft.quaternion.multiply(qx).multiply(qy).multiply(qz).normalize();


            // --- Apply Linear Velocity ---
            const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(playerAircraft.quaternion);
            const acceleration = forwardVector.multiplyScalar(thrust * deltaTime);

            playerVelocity.add(acceleration);

            // Apply damping/drag
            const dragFactor = 1.0 - (0.5 * deltaTime); // Simple linear drag
            playerVelocity.multiplyScalar(dragFactor);

            // Clamp speed
            if (playerVelocity.lengthSq() > maxSpeed * maxSpeed) {
                playerVelocity.normalize().multiplyScalar(maxSpeed);
            }

             // Minimum speed to prevent floating still
            const MIN_SPEED = 5.0;
            if (currentSpeed < MIN_SPEED && thrust === 0) {
                 playerVelocity.multiplyScalar(0.9); // Slow down faster when idle and slow
                 if (currentSpeed < 0.1) playerVelocity.set(0,0,0);
            }


            // --- Update Position ---
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerAircraft.position.add(deltaPosition);

            // --- Ground Collision (Simple) ---
            const groundLevel = 0; // Or terrain height at this position
            if (playerAircraft.position.y < groundLevel + 1) { // +1 for aircraft size buffer
                playerAircraft.position.y = groundLevel + 1;
                playerVelocity.y = Math.max(0, playerVelocity.y * -0.5); // Bounce slightly
            }
        }

        function updateCameraFOV() {
            const speedRatio = playerVelocity.length() / (PLAYER_SPEED * AFTERBURNER_MULTIPLIER);
            const targetFOV = CAMERA_BASE_FOV + speedRatio * CAMERA_MAX_FOV_BOOST;
            // Smooth FOV change
            camera.fov += (targetFOV - camera.fov) * 0.1;
            camera.updateProjectionMatrix();
        }

        function updateDayNightCycle(deltaTime) {
            const cycleSpeed = (2 * Math.PI) / (DAY_NIGHT_CYCLE_MINUTES * 60); // Radians per second
            sunAngle += cycleSpeed * deltaTime;
            sunAngle %= (2 * Math.PI); // Keep angle between 0 and 2PI

            const sunY = Math.sin(sunAngle);
            const sunX = Math.cos(sunAngle);

            sunLight.position.set(sunX * 1500, sunY * 1000, 1000); // Adjust Z for angled light
            sunLight.target.position.set(0, 0, 0); // Keep light focused on the center

            // Adjust light intensity and colors based on sun angle
            if (sunY > 0) { // Daytime
                const intensity = Math.max(0.1, sunY) * 1.5; // Brighter during day, min intensity
                sunLight.intensity = intensity;
                skyLight.intensity = Math.max(0.2, sunY * 0.6); // Ambient light stronger during day
                sunLight.color.setHSL(0.1, 1, Math.max(0.5, sunY)); // Yellowish sun
                skyLight.color.setHSL(0.6, 0.6, Math.max(0.3, sunY * 0.7)); // Bluish sky
                scene.fog.color.setHSL(0.6, 0.3, Math.max(0.6, sunY * 0.8)); // Lighter fog
                scene.fog.near = 1000 + (1-sunY) * 2000; // Fog denser near horizon at dawn/dusk
                scene.fog.far = 15000 - (1-sunY) * 5000;
                renderer.setClearColor(skyLight.color); // Match background to sky
            } else { // Nighttime
                sunLight.intensity = 0; // Sun off
                skyLight.intensity = 0.1 + Math.abs(sunY) * 0.1; // Dim ambient from moon/stars
                skyLight.color.setHSL(0.6, 0.3, 0.1); // Dark blue night sky
                scene.fog.color.setHSL(0.6, 0.1, 0.05); // Darker fog
                scene.fog.near = 500;
                scene.fog.far = 8000;
                 renderer.setClearColor(0x000011); // Dark night background
            }
             // Moon (could be another light source or just affect ambient)
             // For simplicity, we are just using the skyLight for night ambient
        }


        function checkCollisions() {
            // Guard against playerAircraft not being ready or not being a group with children yet
            if (!playerAircraft || !playerAircraft.isGroup || !playerAircraft.children || playerAircraft.children.length === 0) {
                return false; // Not ready to check collisions
            }
    
            // Note: Computing bounding box every frame can be slow for complex models.
            // Consider optimizing this later if needed.
            const playerBox = new THREE.Box3().setFromObject(playerAircraft);
            isColliding = false; // Reset collision state

            for (const buildingBox of buildingBoundingBoxes) {
                if (playerBox.intersectsBox(buildingBox)) {
                    // --- Collision Response ---
                    // Simple response: Stop movement towards the building
                    isColliding = true;

                    // Find collision normal (approximate)
                    const playerCenter = new THREE.Vector3();
                    playerBox.getCenter(playerCenter);
                    const buildingCenter = new THREE.Vector3();
                    buildingBox.getCenter(buildingCenter);

                    const collisionNormal = playerCenter.sub(buildingCenter).normalize();

                    // Reflect velocity (basic bounce) - needs refinement for better feel
                    const speed = playerVelocity.length();
                    if (speed > 1.0) { // Only reflect if moving significantly
                        playerVelocity.reflect(collisionNormal).multiplyScalar(0.5); // Lose half speed on impact
                    } else {
                        playerVelocity.set(0,0,0); // Stop if moving slowly
                    }

                     // Push player slightly out of the building to prevent sticking
                    const pushOut = collisionNormal.multiplyScalar(1.0);
                    playerAircraft.position.add(pushOut);

                    // Maybe add visual/audio feedback for collision here

                    // For this simple check, stop after first collision found in a frame
                    break;
                }
            }

            // Traverse the playerAircraft group to find meshes and modify their materials' emissive property
            playerAircraft.traverse((child) => {
                if (child.isMesh && child.material) {
                    // Handle both single material and array of materials
                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(mat => {
                        // Check if the material type supports emissive (like Standard or Physical)
                        if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                            // Set emissive color based on collision state
                            // Use a brighter red for collision, black (no emission) otherwise
                            // Note: This assumes the base color is handled by the model's texture/material.
                            // If the loaded model isn't red, this will just add/remove a red glow.
                            mat.emissive.setHex(isColliding ? 0xaa0000 : 0x000000);
                        }
                    });
                }
            });

            return isColliding;
        }


        function sendPlayerUpdate() {
            if (!playerAircraft || !playerId) return;

            const data = {
                position: playerAircraft.position.toArray(),
                quaternion: playerAircraft.quaternion.toArray(),
                // Optional: Send velocity, boost state etc. if needed server-side
                // velocity: playerVelocity.toArray(),
                // boosting: controls.boost === 1
            };

            const message = {
                type: 'player_update',
                id: playerId, // Send own ID
                data: data
            };

            try {
                ws.send(JSON.stringify(message));
            } catch (error) {
                 console.error("Failed to send update:", error);
            }
        }

        function updateInfoPanel() {
            const speedKmh = playerVelocity.length() * 3.6; // Example conversion factor
            const altitude = playerAircraft.position.y;
            document.getElementById('speed').textContent = speedKmh.toFixed(0);
            document.getElementById('altitude').textContent = altitude.toFixed(1);
            // Player count updated in WebSocket handlers
        }

         function updatePlayerCount() {
            document.getElementById('players-count').textContent = otherPlayers.size + 1; // +1 for self
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the game ---
        init();

    </script>
</body>
</html>